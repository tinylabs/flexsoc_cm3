/**
 *  Target wrapper to access specific CSRs from com link. This is a very thin
 *  layer to wrap the autogenerated csr classes + native comm layer.
 *
 *  All rights reserved.
 *  Tiny Labs Inc
 *  2020
 */
#ifndef TARGET_H
#define TARGET_H

#include <stdint.h>
#include <stdlib.h>

#include "flexsoc_csr.h"
#include "irq_slave.h"

class Target {

  static Target *inst;

private:
  flexsoc_csr *csr;
  irq_slave *irq;
  Target (char *id);
  
 public:

  // Get singleton instance
  static Target *Ptr (void);
  static Target *Ptr (char *id);

  // Destructor
  virtual ~Target ();

  // General APIs
  void ReadW (uint32_t addr, uint32_t *data, uint32_t cnt);
  void ReadH (uint32_t addr, uint16_t *data, uint32_t cnt);
  void ReadB (uint32_t addr, uint8_t *data, uint32_t cnt);
  void WriteW (uint32_t addr, const uint32_t *data, uint32_t cnt);
  void WriteH (uint32_t addr, const uint16_t *data, uint32_t cnt);
  void WriteB (uint32_t addr, const uint8_t *data, uint32_t cnt);
  uint32_t ReadReg (uint32_t addr);
  void WriteReg (uint32_t addr, uint32_t val);

  // Slave interface
  void SlaveSend (const uint8_t *data, int len);
  void SlaveRegister (void (*cb) (uint8_t *, int));
  void SlaveUnregister (void);
  
  // Trigger IRQ pulse
  void IRQ (uint8_t irq);
  // Set level IRQ
  void IRQSet (uint8_t irq);
  // Clr level IRQ
  void IRQClr (uint8_t irq);
  
  // Access CSRs
  uint32_t FlexsocID (void);
  uint32_t MemoryID (void);
  void CPUReset (bool reset);
  bool CPUReset (void);
  void SlaveEn (bool en);
  bool SlaveEn (void);
  
};

#endif /* TARGET_H */


